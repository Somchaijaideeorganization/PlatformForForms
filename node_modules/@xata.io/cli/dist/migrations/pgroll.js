import path from 'path';
import z from 'zod';
import { safeJSONParse, safeReadFile } from '../utils/files.js';
import { migrationsDir, readMigrationsDir } from './files.js';
import { migrationFilePgroll } from './schema.js';
export const isBranchPgRollEnabled = (details) => {
    // @ts-expect-error TODO: Fix this when api is finalized
    return !!details.usePgRoll;
};
export const isMigrationPgRollFormat = (migration) => {
    return 'migration' in migration;
};
export const hydrateMigrationObject = (migration) => {
    return { ...migration, migration: JSON.parse(migration.migration) };
};
export async function allMigrationsPgRollFormat() {
    const files = await readMigrationsDir();
    for (const file of files) {
        if (file === '.ledger')
            continue;
        const filePath = path.join(migrationsDir, file);
        const fileContents = await safeReadFile(filePath);
        const result = migrationFilePgroll.safeParse(safeJSONParse(fileContents));
        if (!result.success) {
            return false;
        }
    }
    return true;
}
const getPgRollLink = (table, column) => {
    var _a;
    const foreignKeysForTable = table.foreignKeys;
    const foreignKeys = Object.keys(foreignKeysForTable !== null && foreignKeysForTable !== void 0 ? foreignKeysForTable : {});
    for (const key of foreignKeys) {
        const k = foreignKeysForTable[key];
        if (k && ((_a = k.columns) === null || _a === void 0 ? void 0 : _a.includes(column.name))) {
            return k;
        }
    }
    return null;
};
export const xataStringColumns = ['email', 'text', 'string'];
const XataStringColumn = z.object({
    ['xata.type']: z.enum(xataStringColumns)
});
const narrowStringType = (comment) => {
    if (!comment)
        return 'text';
    const result = XataStringColumn.safeParse(JSON.parse(comment));
    return result.success ? result.data['xata.type'] : 'text';
};
function pgRollToXataColumnType(type, comment) {
    switch (type) {
        case 'boolean':
        case 'bool':
            return 'bool';
        case 'bigint':
        case 'int8':
        case 'integer':
        case 'int':
        case 'int4':
        case 'smallint':
            return 'int';
        case 'double precision':
        case 'float8':
        case 'real':
            return 'float';
        case 'text':
        case 'varchar':
        case 'character varying':
            return narrowStringType(comment);
        case 'timestamptz':
            return 'datetime';
        case 'text[]':
            return 'multiple';
        case 'json':
        case 'jsonb':
            return 'json';
        case 'xata_file':
            return 'file';
        case 'xata_file_array':
            return 'file[]';
        case 'real[]':
            return 'vector';
    }
    if (type.startsWith('character(') || type.startsWith('varchar('))
        return 'string';
    if (type.startsWith('numeric('))
        return 'float';
    return type;
}
export async function getBranchDetailsWithPgRoll(xata, { workspace, region, database, branch }) {
    var _a;
    const details = await xata.api.branch.getBranchDetails({
        pathParams: { workspace, region, dbBranchName: `${database}:${branch}` }
    });
    if (isBranchPgRollEnabled(details)) {
        const pgroll = await xata.api.migrations.getSchema({
            pathParams: { workspace, region, dbBranchName: `${database}:${branch}` }
        });
        return {
            ...details,
            branchName: branch,
            createdAt: new Date().toISOString(),
            databaseName: database,
            id: pgroll.schema.name, // Not really
            lastMigrationID: '', // Not really
            version: 1,
            metadata: {},
            schema: {
                tables: Object.entries((_a = pgroll.schema.tables) !== null && _a !== void 0 ? _a : []).map(([name, table]) => {
                    var _a;
                    return ({
                        name,
                        checkConstraints: table.checkConstraints,
                        foreignKeys: table.foreignKeys,
                        primaryKey: table.primaryKey,
                        uniqueConstraints: table.uniqueConstraints,
                        columns: Object.values((_a = table.columns) !== null && _a !== void 0 ? _a : {})
                            .filter((column) => !['_id', '_createdat', '_updatedat', '_version'].includes(column.name))
                            .map((column) => ({
                            name: column.name,
                            type: getPgRollLink(table, column) ? 'link' : pgRollToXataColumnType(column.type, column.comment),
                            link: getPgRollLink(table, column) ? { table: getPgRollLink(table, column).referencedTable } : undefined,
                            file: pgRollToXataColumnType(column.type) === 'file' || pgRollToXataColumnType(column.type) === 'file[]'
                                ? { defaultPublicAccess: false }
                                : undefined,
                            notNull: column.nullable === false,
                            unique: column.unique === true,
                            defaultValue: column.default,
                            comment: column.comment
                        }))
                    });
                })
            }
        };
    }
    return details;
}
export const isColumnTypeUnsupported = (type) => {
    switch (type) {
        case 'bool':
        case 'int':
        case 'float':
        case 'datetime':
        case 'multiple':
        case 'json':
        case 'file':
        case 'file[]':
        case 'text':
        case 'link':
        case 'string':
        case 'email':
        case 'vector':
            return false;
        default:
            return true;
    }
};
export function xataColumnTypeToPgRoll(type) {
    if (isColumnTypeUnsupported(type))
        return type;
    switch (type) {
        case 'bool':
            return 'boolean';
        case 'int':
            return 'bigint';
        case 'float':
            return 'double precision';
        case 'datetime':
            return 'timestamptz';
        case 'multiple':
            return 'text[]';
        case 'json':
            return 'jsonb';
        case 'file':
            return 'xata.xata_file';
        case 'file[]':
            return 'xata.xata_file_array';
        case 'text':
        case 'string':
        case 'email':
        case 'link':
            return 'text';
        case 'vector':
            return 'real[]';
        default:
            return 'text';
    }
}
export const exhaustiveCheck = (x) => {
    throw new Error(`Unhandled discriminated union member: ${x}`);
};
export const generateLinkReference = ({ column, table, onDelete: on_delete = 'SET NULL' }) => {
    return {
        name: `${column}_link`,
        table,
        column: 'xata_id',
        on_delete
    };
};
export const xataColumnTypeToPgRollConstraintName = (tableName, columnName, columnType) => {
    return `${tableName}_xata_${columnType}_length_${columnName}`;
};
export const xataColumnTypeToPgRollConstraint = (column, table) => {
    const getConstraint = () => {
        var _a;
        if (isColumnTypeUnsupported(column.type))
            return undefined;
        switch (column.type) {
            case 'vector':
                return `ARRAY_LENGTH("${column.name}", 1) = ${(_a = column.vector) === null || _a === void 0 ? void 0 : _a.dimension}`;
            case 'string':
            case 'email':
                return `LENGTH("${column.name}") <= 2048`;
            case 'text':
                return `OCTET_LENGTH("${column.name}") <= 204800`;
            case 'multiple':
                return `OCTET_LENGTH(ARRAY_TO_STRING("${column.name}", '')) < 65536`;
            case 'link':
            case 'bool':
            case 'datetime':
            case 'file':
            case 'file[]':
            case 'float':
            case 'int':
            case 'json':
                return undefined;
            default:
                return undefined;
        }
    };
    const constraint = getConstraint();
    return constraint
        ? {
            name: xataColumnTypeToPgRollConstraintName(table, column.name, column.type),
            constraint
        }
        : undefined;
};
export const xataColumnTypeToPgRollComment = (column) => {
    const getType = () => {
        var _a, _b, _c, _d, _e, _f;
        switch (column.type) {
            case 'vector':
                return { 'xata.search.dimension': (_a = column.vector) === null || _a === void 0 ? void 0 : _a.dimension };
            case 'link':
                return { 'xata.link': (_b = column.link) === null || _b === void 0 ? void 0 : _b.table };
            case 'string':
            case 'text':
            case 'email':
                return { 'xata.type': column.type };
            case 'file':
                return { 'xata.file.dpa': (_d = (_c = column.file) === null || _c === void 0 ? void 0 : _c.defaultPublicAccess) !== null && _d !== void 0 ? _d : false };
            case 'file[]':
                return { 'xata.file.dpa': (_f = (_e = column['file[]']) === null || _e === void 0 ? void 0 : _e.defaultPublicAccess) !== null && _f !== void 0 ? _f : false };
            case 'float':
            case 'int':
            case 'json':
            case 'multiple':
            case 'bool':
            case 'datetime':
                return undefined;
            default:
                return 'text';
        }
    };
    const result = getType();
    return result !== undefined ? JSON.stringify(result) : undefined;
};
export const requiresUpArgument = (notNull, defaultValue) => notNull && (defaultValue === null || defaultValue === undefined);
export function xataColumnTypeToZeroValue(type, defaultValue) {
    if (defaultValue !== undefined && defaultValue !== null)
        return `${defaultValue}`;
    if (isColumnTypeUnsupported(type))
        return "''";
    switch (type) {
        case 'bool':
            return 'false';
        case 'int':
        case 'float':
            return '0';
        case 'datetime':
            return 'now()';
        case 'link':
            return 'null';
        case 'email':
        case 'text':
        case 'string':
            return "''";
        case 'vector':
        case 'multiple':
        case 'json':
        case 'file':
        case 'file[]':
            return "'{}'";
        default:
            return "''";
    }
}
export async function waitForMigrationToFinish(api, workspace, region, database, branch, jobId) {
    const { status, error } = await api.migrations.getMigrationJobStatus({
        pathParams: {
            workspace: workspace,
            region: region,
            dbBranchName: `${database}:${branch}`,
            jobId
        }
    });
    if (status === 'failed') {
        throw new Error(`Migration failed, ${error}`);
    }
    if (status === 'completed') {
        return;
    }
    await new Promise((resolve) => setTimeout(resolve, 1000));
    return await waitForMigrationToFinish(api, workspace, region, database, branch, jobId);
}
const getTable = (tableName, branchDetails) => {
    return branchDetails === null || branchDetails === void 0 ? void 0 : branchDetails.schema.tables.find((table) => table.name === tableName);
};
export const updateConstraint = (branchDetails, operation) => {
    var _a, _b;
    const migrations = [];
    const getUpdatedConstraintName = (params) => {
        var _a, _b;
        const { constraintName, replacement, type } = params;
        const baseRegex = '_xata_(?:vector|string|text|multiple|email)_length_';
        const regex = type === 'table' ? new RegExp(`(.*)${baseRegex}(?:.*)`, 'dgm') : new RegExp(`(?:.*)${baseRegex}(.*)`, 'dgm');
        const matches = regex.exec(constraintName);
        if (!matches)
            return constraintName;
        // e.g. of indices: [ [ 0, 24 ], [ 22, 24 ]
        if (((_a = matches === null || matches === void 0 ? void 0 : matches.indices) === null || _a === void 0 ? void 0 : _a.length) !== 2 || ((_b = matches === null || matches === void 0 ? void 0 : matches.indices[0]) === null || _b === void 0 ? void 0 : _b.length) !== 2)
            return constraintName;
        const start = matches.indices[1][0];
        const finish = matches.indices[1][1];
        const arr = constraintName.split('');
        arr.splice(start, finish, replacement);
        return arr.join('');
    };
    if ('alter_column' in operation &&
        operation.alter_column.name &&
        operation.alter_column.name !== operation.alter_column.column) {
        const table = getTable(operation.alter_column.table, branchDetails);
        if (!table)
            return undefined;
        const oldColumn = table.columns
            .map(({ type, name, comment }) => ({ type, name, comment }))
            .find((column) => column.name === operation.alter_column.column);
        if (!oldColumn)
            return undefined;
        const oldColumnType = pgRollToXataColumnType(oldColumn.type, oldColumn.comment);
        if (!oldColumnType)
            return undefined;
        const constraint = Object.values((_a = table.checkConstraints) !== null && _a !== void 0 ? _a : {}).find((constraint) => constraint.name ===
            xataColumnTypeToPgRollConstraintName(table.name, operation.alter_column.column, oldColumnType));
        if (!constraint)
            return undefined;
        const newConstraintName = getUpdatedConstraintName({
            constraintName: constraint.name,
            replacement: operation.alter_column.name,
            type: 'column'
        });
        if (newConstraintName === constraint.name)
            return undefined;
        migrations.push({
            rename_constraint: {
                table: table.name,
                from: constraint.name,
                to: newConstraintName
            }
        });
    }
    if ('rename_table' in operation) {
        const table = getTable(operation.rename_table.from, branchDetails);
        if (!table)
            return undefined;
        Object.values((_b = table.checkConstraints) !== null && _b !== void 0 ? _b : {}).forEach((constraint) => {
            const newConstraintName = getUpdatedConstraintName({
                constraintName: constraint.name,
                replacement: operation.rename_table.to,
                type: 'table'
            });
            if (newConstraintName === constraint.name)
                return undefined;
            migrations.push({
                rename_constraint: {
                    table: operation.rename_table.to,
                    from: constraint.name,
                    to: newConstraintName
                }
            });
        });
    }
    return migrations.length > 0 ? migrations : undefined;
};
const isValidXataLink = ({ key }) => {
    return key.referencedColumns.length === 1 && key.referencedColumns.includes('xata_id');
};
export const updateLinkComment = (branchDetails, operation) => {
    var _a;
    const migrationSql = [];
    if ('rename_table' in operation) {
        const tablesToUpdate = (_a = branchDetails === null || branchDetails === void 0 ? void 0 : branchDetails.schema.tables.reduce((acc, table) => {
            const keys = Object.values(table.foreignKeys);
            for (const key of keys) {
                if (key.referencedTable === operation.rename_table.from && isValidXataLink({ key })) {
                    acc.push({ [table.name]: key.columns });
                }
            }
            return acc;
        }, [])) !== null && _a !== void 0 ? _a : [];
        for (const key of tablesToUpdate) {
            const tableName = Object.keys(key)[0];
            const columns = key[tableName];
            columns.forEach((column) => {
                var _a;
                const table = getTable(tableName, branchDetails);
                const columnToUpdate = table === null || table === void 0 ? void 0 : table.columns.find((col) => col.name === column);
                if (tableNameFromLinkComment((_a = columnToUpdate === null || columnToUpdate === void 0 ? void 0 : columnToUpdate.comment) !== null && _a !== void 0 ? _a : '')) {
                    migrationSql.push(`COMMENT ON COLUMN "${tableName}"."${column}" IS '${JSON.stringify({
                        'xata.link': operation.rename_table.to
                    })}'`);
                }
            });
        }
    }
    return migrationSql.length > 0 ? [{ sql: { up: migrationSql.join(';') } }] : undefined;
};
const XataLinkColumn = z.object({
    ['xata.link']: z.string()
});
export const tableNameFromLinkComment = (comment) => {
    try {
        const obj = JSON.parse(comment);
        const result = XataLinkColumn.safeParse(obj);
        return result.success ? result.data['xata.link'] : null;
    }
    catch (e) {
        return null;
    }
};
