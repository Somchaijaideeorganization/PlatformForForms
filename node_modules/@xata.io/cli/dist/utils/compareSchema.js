import { generateLinkReference, tableNameFromLinkComment, xataColumnTypeToPgRoll } from '../migrations/pgroll.js';
import { INTERNAL_COLUMNS_PGROLL } from '../commands/import/csv.js';
export function compareSchemas({ source, target }) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;
    const edits = [];
    // Compare tables
    const sourceTables = Object.keys((_a = source.tables) !== null && _a !== void 0 ? _a : {});
    const targetTables = Object.keys((_b = target.tables) !== null && _b !== void 0 ? _b : {});
    const newTables = targetTables.filter((table) => !sourceTables.includes(table));
    const deletedTables = sourceTables.filter((table) => !targetTables.includes(table));
    // Compare columns
    for (const table of sourceTables) {
        const sourceColumns = Object.keys((_e = (_d = (_c = source.tables) === null || _c === void 0 ? void 0 : _c[table]) === null || _d === void 0 ? void 0 : _d.columns) !== null && _e !== void 0 ? _e : {}).filter((c) => !INTERNAL_COLUMNS_PGROLL.includes(c));
        const targetColumns = Object.keys((_h = (_g = (_f = target.tables) === null || _f === void 0 ? void 0 : _f[table]) === null || _g === void 0 ? void 0 : _g.columns) !== null && _h !== void 0 ? _h : {}).filter((c) => !INTERNAL_COLUMNS_PGROLL.includes(c));
        const newColumns = targetColumns.filter((column) => !sourceColumns.includes(column));
        const deletedColumns = sourceColumns.filter((column) => !targetColumns.includes(column));
        // Add columns
        for (const column of newColumns) {
            const props = (_m = (_l = (_k = (_j = target.tables) === null || _j === void 0 ? void 0 : _j[table]) === null || _k === void 0 ? void 0 : _k.columns) === null || _l === void 0 ? void 0 : _l[column]) !== null && _m !== void 0 ? _m : {};
            edits.push({
                add_column: {
                    table,
                    column: {
                        name: column,
                        type: xataColumnTypeToPgRoll(props === null || props === void 0 ? void 0 : props.type),
                        comment: props === null || props === void 0 ? void 0 : props.comment,
                        nullable: !((props === null || props === void 0 ? void 0 : props.nullable) === false),
                        unique: props === null || props === void 0 ? void 0 : props.unique,
                        default: (_o = props === null || props === void 0 ? void 0 : props.default) !== null && _o !== void 0 ? _o : undefined,
                        references: (props === null || props === void 0 ? void 0 : props.type) === 'link' && (props === null || props === void 0 ? void 0 : props.name)
                            ? generateLinkReference({
                                column: props.name,
                                table: (_q = tableNameFromLinkComment((_p = props === null || props === void 0 ? void 0 : props.comment) !== null && _p !== void 0 ? _p : '')) !== null && _q !== void 0 ? _q : ''
                            })
                            : undefined
                    }
                }
            });
        }
        // Delete columns
        for (const column of deletedColumns) {
            edits.push({ drop_column: { table, column } });
        }
    }
    // Delete tables
    for (const table of deletedTables) {
        edits.push({ drop_table: { name: table } });
    }
    // Add new tables
    for (const table of newTables) {
        const props = (_s = (_r = target.tables) === null || _r === void 0 ? void 0 : _r[table]) !== null && _s !== void 0 ? _s : {};
        edits.push({
            create_table: {
                name: table,
                comment: props.comment,
                columns: Object.entries((_t = props.columns) !== null && _t !== void 0 ? _t : {})
                    .filter(([name, _]) => !INTERNAL_COLUMNS_PGROLL.includes(name))
                    .map(([name, column]) => {
                    var _a, _b, _c;
                    return {
                        name,
                        type: xataColumnTypeToPgRoll(column === null || column === void 0 ? void 0 : column.type),
                        comment: column === null || column === void 0 ? void 0 : column.comment,
                        nullable: !((column === null || column === void 0 ? void 0 : column.nullable) === false),
                        unique: column === null || column === void 0 ? void 0 : column.unique,
                        default: (_a = column === null || column === void 0 ? void 0 : column.default) !== null && _a !== void 0 ? _a : undefined,
                        references: (column === null || column === void 0 ? void 0 : column.type) === 'link' && (column === null || column === void 0 ? void 0 : column.name)
                            ? generateLinkReference({
                                column: column === null || column === void 0 ? void 0 : column.name,
                                table: (_c = tableNameFromLinkComment((_b = column === null || column === void 0 ? void 0 : column.comment) !== null && _b !== void 0 ? _b : '')) !== null && _c !== void 0 ? _c : ''
                            })
                            : undefined
                    };
                })
            }
        });
    }
    return { edits };
}
export const inferOldSchemaToNew = (oldSchema) => {
    const schema = {
        name: oldSchema.branchName,
        tables: Object.fromEntries(oldSchema.schema.tables.map((table) => [
            table.name,
            {
                name: table.name,
                xataCompatible: true,
                comment: '',
                primaryKey: 'id',
                uniqueConstraints: [],
                checkConstraints: [],
                foreignKeys: [],
                columns: Object.fromEntries(table.columns.map((column) => [
                    column.name,
                    {
                        name: column.name,
                        type: oldColumnTypeToNew(column),
                        comment: generateCommentFromOldColumn(column),
                        nullable: !(column.notNull === true),
                        unique: column.unique === true,
                        defaultValue: column.defaultValue
                    }
                ]))
            }
        ]))
    };
    return schema;
};
const oldColumnTypeToNew = (oldColumn) => {
    // These types will be limited to the original deprecated Xata types
    switch (oldColumn.type) {
        case 'bool':
            return 'boolean';
        case 'datetime':
            return 'timestamptz';
        case 'vector':
            return 'vector';
        case 'json':
            return 'jsonb';
        case 'file':
            return 'xata_file';
        case 'file[]':
            return 'xata_file_array';
        case 'int':
            return 'integer';
        case 'float':
            return 'real';
        case 'multiple':
            return 'text[]';
        case 'text':
        case 'string':
        case 'email':
            return 'text';
        case 'link':
            return 'link';
        default:
            return 'text';
    }
};
const generateCommentFromOldColumn = (oldColumn) => {
    var _a, _b, _c, _d, _e;
    switch (oldColumn.type) {
        case 'vector':
            return JSON.stringify({ 'xata.search.dimension': (_a = oldColumn.vector) === null || _a === void 0 ? void 0 : _a.dimension });
        case 'file':
            return JSON.stringify({ 'xata.file.dpa': (_b = oldColumn === null || oldColumn === void 0 ? void 0 : oldColumn.file) === null || _b === void 0 ? void 0 : _b.defaultPublicAccess });
        case 'file[]':
            return JSON.stringify({ 'xata.file.dpa': (_c = oldColumn === null || oldColumn === void 0 ? void 0 : oldColumn['file[]']) === null || _c === void 0 ? void 0 : _c.defaultPublicAccess });
        case 'link':
            return ((_d = oldColumn.link) === null || _d === void 0 ? void 0 : _d.table) ? generateLinkComment((_e = oldColumn.link) === null || _e === void 0 ? void 0 : _e.table) : '';
        case 'string':
        case 'email':
            return JSON.stringify({ 'xata.type': oldColumn.type });
        default:
            return '';
    }
};
const generateLinkComment = (tableName) => {
    return JSON.stringify({ 'xata.link': tableName });
};
